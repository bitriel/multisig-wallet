{
  "language": "Solidity",
  "sources": {
    "contracts/MultiSigWallet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\n\n/// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution.\ncontract MultiSigWallet {\n  using SafeMath for uint256;\n  using SafeCast for uint8;\n  using SafeERC20 for IERC20;\n\n  event TransactionApproved(address indexed sender, uint256 indexed transactionId);\n  event ApprovalRevoked(address indexed sender, uint256 indexed transactionId);\n  event TransactionSubmitted(uint256 indexed transactionId);\n  event TransactionExecuted(uint256 indexed transactionId);\n  event ExecutionFailed(uint256 indexed transactionId);\n  event Deposited(address indexed sender, uint256 value);\n  event TokenDeposited(address indexed sender, IERC20 indexed token, uint256 value);\n  event NewOwnerAdded(address indexed owner);\n  event OwnerRemoval(address indexed owner);\n  event RequirementChanged(uint256 required);\n\n  enum Kind {\n    Transfer,\n    ChangeApprovals,\n    AddOwner,\n    RemoveOwner,\n    ReplaceOwner\n  }\n\n  struct Transaction {\n    Kind kind;\n    address to;\n    uint value;\n    bytes data;\n    address token;\n    uint8 approval;\n    bool executed;\n  }\n\n  uint8 constant public MAX_OWNER = 50;\n\n  mapping (uint256 => Transaction) public transactions;\n  mapping (uint256 => mapping (address => bool)) public approvals;\n  mapping (address => bool) public owners;\n  // address[] public owners;\n  uint8 public required;\n  uint8 public ownerCount;\n  uint256 public transactionCount;\n\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\n  /// @param _owners List of initial owners.\n  /// @param _required Number of required confirmations.\n  constructor(address[] memory _owners, uint8 _required) \n    validate(uint8(_owners.length), _required) \n  {\n    required = _required;\n    ownerCount = uint8(_owners.length);\n\n    for (uint8 i=0; i<_owners.length; i++) {\n      require(!owners[_owners[i]], \"initial owners are duplicated\");\n      owners[_owners[i]] = true;\n    }\n  }\n\n  /// @dev deposit native token into this contract.\n  receive() external payable {\n    if (msg.value > 0)\n      emit Deposited(msg.sender, msg.value);\n  }\n\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n  /// @param _owner Address of new owner.\n  function addOwner(address _owner) external\n    isValid(_owner)\n    notOwner(_owner)\n    validate(ownerCount + 1, required)\n    returns (uint256 txnId)\n  {\n    txnId = _addTransaction(Kind.AddOwner, address(0), address(0), 0, abi.encode(_owner));\n    approve(txnId);\n  }\n\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n  /// @param _owner Address of owner.\n  function removeOwner(address _owner) external\n    isOwner(_owner)\n    returns (uint256 txnId)\n  {\n    txnId = _addTransaction(Kind.RemoveOwner, address(0), address(0), 0, abi.encode(_owner));\n    approve(txnId);\n  }\n\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n  /// @param _owner Address of owner to be replaced.\n  /// @param _newOwner Address of new owner.\n  function replaceOwner(address _owner, address _newOwner) external\n    isValid(_newOwner)\n    isOwner(_owner)\n    notOwner(_newOwner)\n    returns (uint256 txnId)\n  {\n    txnId = _addTransaction(Kind.ReplaceOwner, address(0), address(0), 0, abi.encode(_owner, _newOwner));\n    approve(txnId);\n  }\n\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n  /// @param _required Number of required confirmations.\n  function changeRequired(uint8 _required) public\n    validate(ownerCount, _required)\n    returns (uint256 txnId)\n  {\n    txnId = _addTransaction(Kind.ChangeApprovals, address(0), address(0), 0, abi.encode(_required));\n    approve(txnId);\n  }\n\n  /// @dev Allows an owner to submit and approve a transaction.\n  /// @param _to transaction destination address\n  /// @param _value transaction value in Wei.\n  /// @param _data transaction data payload.\n  /// @return txnId returns transaction ID.\n  function transfer(address payable _to, uint256 _value, bytes memory _data) external\n    isValid(_to)\n    isEnough(_value)\n    returns (uint256 txnId)\n  {\n    txnId = _addTransaction(Kind.Transfer, address(0), _to, _value, _data);\n    approve(txnId);\n  }\n\n  /// @dev Allows an owner to submit and approve a transaction on BEP-20 tokens.\n  /// @param _token a BEP-20 token address\n  /// @param _to transaction destination address\n  /// @param _value transaction value in Wei.\n  /// @param _data transaction data payload.\n  /// @return txnId returns transaction ID.\n  function transferToken(IERC20 _token, address payable _to, uint256 _value, bytes memory _data) external \n    isValid(_to)\n    isTokenEnough(_token, _value)\n    returns (uint256 txnId) \n  {\n    txnId = _addTransaction(Kind.Transfer, address(_token), _to, _value, _data);\n    approve(txnId);\n  }\n\n  /// @dev Allows an owner to approve a transaction.\n  /// @param _txnId transaction ID.\n  function approve(uint256 _txnId) public\n    isOwner(msg.sender)\n    hasTransaction(_txnId)\n    notApproved(_txnId, msg.sender)\n  {\n    transactions[_txnId].approval++;\n    approvals[_txnId][msg.sender] = true;\n\n    emit TransactionApproved(msg.sender, _txnId);\n    execute(_txnId);\n  }\n\n  /// @dev Allows an owner to revoke a approval for a transaction.\n  /// @param _txnId transaction ID.\n  function revokeApproval(uint256 _txnId) external\n    isOwner(msg.sender)\n    approved(_txnId, msg.sender)\n    notExecuted(_txnId)\n  {\n    transactions[_txnId].approval--;\n    approvals[_txnId][msg.sender] = false;\n    \n    emit ApprovalRevoked(msg.sender, _txnId);\n  }\n\n  /// @dev Allows anyone to execute a approved transaction.\n  /// @param _txnId transaction ID.\n  /// @return success wether it's success\n  function execute(uint256 _txnId) public\n    isOwner(msg.sender)\n    approved(_txnId, msg.sender)\n    notExecuted(_txnId)\n    returns (bool success)\n  {\n    if (isConfirmed(_txnId)) {\n      Transaction storage txn = transactions[_txnId];\n\n      if (txn.kind == Kind.ChangeApprovals) {\n        (required) = abi.decode(txn.data, (uint8));\n\n        emit RequirementChanged(required);\n      } else if (txn.kind == Kind.AddOwner) {\n        (address newOwner) = abi.decode(txn.data, (address));\n        owners[newOwner] = true;\n        ownerCount++;\n\n        emit NewOwnerAdded(newOwner);\n      } else if (txn.kind == Kind.RemoveOwner) {\n        (address oldOwner) = abi.decode(txn.data, (address));\n        delete owners[oldOwner];\n        ownerCount--;\n\n        emit OwnerRemoval(oldOwner);\n\n        if (required > ownerCount) {\n          required = ownerCount;\n\n          emit RequirementChanged(required);\n        }\n      } else if (txn.kind == Kind.ReplaceOwner) {\n        (address oldOwner, address newOwner) = abi.decode(txn.data, (address, address));\n        delete owners[oldOwner];\n        owners[newOwner] = true;\n\n        emit OwnerRemoval(oldOwner);\n        emit NewOwnerAdded(newOwner);\n      } else if (txn.kind == Kind.Transfer) {\n        if (txn.token == address(0)) \n          payable(txn.to).transfer(txn.value);\n        else \n          IERC20(txn.token).safeTransfer(payable(txn.to), txn.value);\n      }\n      txn.executed = true;\n      emit TransactionExecuted(_txnId);\n\n      return txn.executed;\n    }\n  }\n\n  /// @dev Returns the confirmation status of a transaction.\n  /// @param _txnId transaction ID.\n  /// @return status confirmation status.\n  function isConfirmed(uint _txnId) public view returns (bool status) {\n    status = transactions[_txnId].approval >= required;\n  }\n\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\n  /// @param _token `0x` if token is native, otherwise is BEP20 token address\n  /// @param _to transaction destination address\n  /// @param _value transaction value in Wei.\n  /// @param _data transaction data payload.\n  /// @return txnId returns transaction ID.\n  function _addTransaction(Kind kind, address _token, address _to, uint _value, bytes memory _data) internal\n    returns (uint txnId)\n  {\n    txnId = transactionCount++;\n    transactions[txnId] = Transaction({\n      kind: kind,\n      to: _to,\n      value: _value,\n      data: _data,\n      token: _token,\n      approval: 0,\n      executed: false\n    });\n    \n    emit TransactionSubmitted(txnId);\n  }\n\n  /// @dev Returns number of approvals of a transaction.\n  /// @param _txnId transaction ID.\n  /// @return count Number of approvals.\n  function getApprovalCount(uint _txnId) external view returns (uint8 count) {\n    count = transactions[_txnId].approval;\n  }\n\n  /// @dev Returns total number of transactions which filers are applied.\n  /// @param _pending Include pending transactions.\n  /// @param _executed Include executed transactions.\n  /// @return count Total number of transactions after filters are applied.\n  function getTransactionCount(bool _pending, bool _executed) external view returns (uint256 count)\n  {\n    for (uint256 i=0; i<transactionCount; i++)\n      if (_pending && !transactions[i].executed || _executed && transactions[i].executed)\n        count++;\n  }\n\n  // /// @dev Returns list of owners.\n  // /// @return List of owner addresses.\n  // function getOwners()\n  //     public\n  //     constant\n  //     returns (address[])\n  // {\n  //     return owners;\n  // }\n\n  // /// @dev Returns array with owner addresses, which confirmed transaction.\n  // /// @param transactionId Transaction ID.\n  // /// @return Returns array of owner addresses.\n  // function getConfirmations(uint transactionId)\n  //     public\n  //     constant\n  //     returns (address[] _confirmations)\n  // {\n  //     address[] memory confirmationsTemp = new address[](owners.length);\n  //     uint count = 0;\n  //     uint i;\n  //     for (i=0; i<owners.length; i++)\n  //         if (confirmations[transactionId][owners[i]]) {\n  //             confirmationsTemp[count] = owners[i];\n  //             count += 1;\n  //         }\n  //     _confirmations = new address[](count);\n  //     for (i=0; i<count; i++)\n  //         _confirmations[i] = confirmationsTemp[i];\n  // }\n\n  // /// @dev Returns list of transaction IDs in defined range.\n  // /// @param _from Index start position of transaction array.\n  // /// @param _to Index end position of transaction array.\n  // /// @param __pending Include pending transactions.\n  // /// @param _executed Include executed transactions.\n  // /// @return Returns array of transaction IDs.\n  // function getTransactionIds(uint256 _from, uint256 _to, bool _pending, bool _executed) external view\n  //   returns (uint256[] memory transactionIds)\n  // {\n  //   uint256[] memory temp;\n  //   for (uint256 i=_from; i<=_to; i++)\n  //     if (_pending && !transactions[i].executed || _executed && transactions[i].executed)\n  //       temp.push(i);\n    \n  //   transactionIds = temp;\n  // }\n\n  modifier notOwner(address _owner) {\n    require(!owners[_owner], \"this address is one of the owners\");\n    _;\n  }\n\n  modifier isOwner(address _owner) {\n    require(owners[_owner], \"this address is not one of the owners\");\n    _;\n  }\n\n  modifier hasTransaction(uint256 _txnId) {\n    require(_txnId < transactionCount, \"transaction is not exist\");\n    _;\n  }\n\n  modifier approved(uint256 _txnId, address _owner) {\n    require(approvals[_txnId][_owner], \"transaction has not been approved by this owner\");\n    _;\n  }\n\n  modifier notApproved(uint256 _txnId, address _owner) {\n    require(!approvals[_txnId][_owner], \"transaction has been approved by this owner\");\n    _;\n  }\n\n  modifier notExecuted(uint256 _txnId) {\n    require(!transactions[_txnId].executed, \"transaction is executed\");\n    _;\n  }\n\n  modifier isValid(address _address) {\n    require(_address != address(0), \"this address is zero address\");\n    _;\n  }\n\n  modifier validate(uint8 _ownerCount, uint8 _required) {\n    require(_required > 1 && _ownerCount <= MAX_OWNER && _required <= _ownerCount,\n      \"required and owner count is not sufficient\"\n    );\n    _;\n  }\n\n  modifier isEnough(uint256 _value) {\n    require(address(this).balance >= _value, \"balance is not enough for transfer\");\n    _;\n  }\n\n  modifier isTokenEnough(IERC20 _token, uint256 _value) {\n    require(_token.balanceOf(address(this)) >= _value, \"BEP20 balance is not enough for transfer\");\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/MultiSigWalletFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0;\n\nimport \"./MultiSigWallet.sol\";\n\n\n/// @title Multi signature wallet factory - Allows creation of multisig wallet.\ncontract MultiSigWalletFactory {\n    event WalletCreated(address creator, address wallet);\n\n    mapping(address => bool) public isWallet;\n    mapping(address => address[]) public wallets;\n\n    /// @dev Returns number of wallets by creator.\n    /// @param creator Contract creator.\n    /// @return count Returns number of wallets by creator.\n    function getWalletsCount(address creator) public view returns (uint256 count) {\n        count = wallets[creator].length;\n    }\n\n    /// @dev Allows verified creation of multisignature wallet.\n    /// @param _owners List of initial owners.\n    /// @param _required Number of required confirmations.\n    /// @return wallet Returns wallet address.\n    function create(address[] memory _owners, uint8 _required) public returns (address wallet) {\n        wallet = address(new MultiSigWallet(_owners, _required));\n        isWallet[wallet] = true;\n        wallets[msg.sender].push(wallet);\n        emit WalletCreated(msg.sender, wallet);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}